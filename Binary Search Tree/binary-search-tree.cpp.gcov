        -:    0:Source:binary-search-tree.cpp
        -:    0:Graph:binary-search-tree.gcno
        -:    0:Data:binary-search-tree.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:#include <iostream>
        -:    2:#include "binary-search-tree.h"
        -:    3:
        -:    4:using namespace std;//Once again, this is not a good practice!
        -:    5:
        7:    6:Node::Node(int x){
        7:    7:  data = x;
        7:    8:  left = right = NULL;
        7:    9:}
        1:   10:Tree::Tree(int x){
        1:   11:  root = new Node(x);
        1:   12:}
       16:   13:Node* Tree::insert(Node* subRoot, int x){
       16:   14:  if(subRoot == NULL){
        6:   15:    return new Node(x);
        -:   16:  }
       10:   17:  if(x < subRoot->data){
        5:   18:    subRoot->left = insert(subRoot->left, x);
        -:   19:  }else{
        5:   20:    subRoot->right = insert(subRoot->right,x);
        -:   21:  }
       10:   22:  return subRoot;
        -:   23:}
        6:   24:void Tree::insert(int x){
        6:   25:  insert(root,x);
        6:   26:}
    #####:   27:Node* Tree::deleteNode(Node *subRoot, int x){
    #####:   28:  if(subRoot==NULL){
    #####:   29:    return subRoot;
        -:   30:  }
    #####:   31:  if(subRoot->data > x){
    #####:   32:    subRoot->left = deleteNode(subRoot->left,x);
    #####:   33:    return subRoot;
    #####:   34:  }else if(subRoot->data < x){
    #####:   35:    subRoot->right = deleteNode(subRoot->right,x);
    #####:   36:    return subRoot;
        -:   37:  }
    #####:   38:  if(subRoot->left==NULL){
    #####:   39:    Node* temp=subRoot->right;
    #####:   40:    delete subRoot;
    #####:   41:    return temp;
    #####:   42:  }else if(subRoot->right==NULL){
    #####:   43:    Node* temp=subRoot->left;
    #####:   44:    delete subRoot;
    #####:   45:    return temp;
        -:   46:  }else{
    #####:   47:    Node * successorParent=subRoot->right;//For sure it's on the right!
        -:   48:    
    #####:   49:    Node * successor =subRoot->right;
    #####:   50:    while(successor->left!=NULL){//For sure is on the left!
    #####:   51:      successorParent=successor;
    #####:   52:      successor=successor->left;
        -:   53:    }
    #####:   54:    successorParent->left=successor->right;
        -:   55:    
    #####:   56:    subRoot->data = successor->data;
        -:   57:    
    #####:   58:    delete successor;
    #####:   59:    return subRoot;
        -:   60:  }
        -:   61:}
    #####:   62:void Tree::deleteNode(int x){
    #####:   63:  deleteNode(root,x);
    #####:   64:}
       15:   65:void Tree::inOrderTraverse(Node* subRoot){
       15:   66:  if(subRoot!=NULL){
        7:   67:    inOrderTraverse(subRoot->left);
        7:   68:    cout<<subRoot->data<<" ";
        7:   69:    inOrderTraverse(subRoot->right);
        -:   70:  }
       15:   71:}
       15:   72:void Tree::preOrderTraverse(Node* subRoot){
       15:   73:  if(subRoot!=NULL){
        7:   74:    cout<<subRoot->data<<" ";
        7:   75:    preOrderTraverse(subRoot->left);
        7:   76:    preOrderTraverse(subRoot->right);
        -:   77:  }
       15:   78:}
       15:   79:void Tree::postOrderTraverse(Node* subRoot){
       15:   80:  if(subRoot!=NULL){
        7:   81:    postOrderTraverse(subRoot->left);
        7:   82:    postOrderTraverse(subRoot->right);
        7:   83:    cout<<subRoot->data<<" ";
        -:   84:  }
       15:   85:}
        1:   86:void Tree::inOrderTraverse(){
        1:   87:  inOrderTraverse(root);
        1:   88:}
        1:   89:void Tree::preOrderTraverse(){
        1:   90:  preOrderTraverse(root);
        1:   91:}
        1:   92:void Tree::postOrderTraverse(){
        1:   93:  postOrderTraverse(root);
        1:   94:}
        -:   95:
